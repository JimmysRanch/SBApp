name: Prod Rollout

on:
  workflow_dispatch:
    inputs:
      env:
        description: "Target environment (must be 'production')"
        required: true
        default: "production"
      confirm_prod:
        description: 'Type YES to confirm live production rollout'
        required: true
        default: "NO"
      pr_number:
        description: "PR number to comment on (default 328)"
        required: false
        default: "328"

env:
  ROLLOUT_TIMESTAMP: ${{ github.run_id }}-${{ github.run_number }}

jobs:
  prod-rollout:
    name: Run Production Rollout
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Validate inputs
        run: |
          if [ "${{ github.event.inputs.env }}" != "production" ]; then
            echo "ERROR: env must be 'production'." >&2
            exit 1
          fi
          if [ "${{ github.event.inputs.confirm_prod }}" != "YES" ]; then
            echo "ERROR: confirm_prod must be YES to proceed." >&2
            exit 1
          fi

      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install supabase CLI
        run: |
          curl -fsSL https://deno.land/install.sh | sh -s v1.46.3
          export DENO_INSTALL="$HOME/.deno"
            export PATH="$DENO_INSTALL/bin:$PATH"
          curl -fsSL https://github.com/supabase/cli/releases/download/v1.189.6/supabase_1.189.6_linux_amd64.tar.gz \
            | tar -xz -C /usr/local/bin supabase
          supabase --version

      - name: Configure Supabase project ref
        run: |
          echo "project_id = \"${{ secrets.SUPABASE_PROJECT_REF }}\"" > supabase/config.toml

      - name: Supabase DB Push (Migrations)
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          supabase db push --project-ref "${{ secrets.SUPABASE_PROJECT_REF }}"

      - name: Prepare psql
        run: |
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client

      - name: Audit & Revoke anon EXECUTE on RPCs
        id: rpc_audit
        env:
          PGHOST: db.${{ secrets.SUPABASE_PROJECT_REF }}.supabase.co
          PGPORT: 6543
          PGUSER: postgres
          PGPASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
          PGDATABASE: postgres
        run: |
          set -e
          echo "== Current function ACLs =="
          psql -v ON_ERROR_STOP=1 <<'SQL'
          select
            n.nspname as schema,
            p.proname as function,
            p.prosecdef as security_definer,
            p.proacl
          from pg_proc p
          join pg_namespace n on n.oid = p.pronamespace
          where n.nspname='app'
            and p.proname in ('list_staff','list_clients','revenue_summary','employee_workload')
          order by p.proname;
          SQL

          echo "== Revoking anon (idempotent) =="
          psql -v ON_ERROR_STOP=1 <<'SQL'
          DO $$
          DECLARE r RECORD;
          BEGIN
            FOR r IN
              select p.proname, pg_get_function_identity_arguments(p.oid) as args
              from pg_proc p
              join pg_namespace n on n.oid = p.pronamespace
              where n.nspname='app'
                and p.proname in ('list_staff','list_clients','revenue_summary','employee_workload')
            LOOP
              EXECUTE format('REVOKE EXECUTE ON FUNCTION app.%I(%s) FROM anon;', r.proname, r.args);
            END LOOP;
          END$$;
          SQL

          echo "== Post-revoke function ACLs =="
          psql -v ON_ERROR_STOP=1 <<'SQL'
          select
            p.proname,
            unnest(coalesce(p.proacl, ARRAY[]::aclitem[])) acl
          from pg_proc p
          join pg_namespace n on n.oid = p.pronamespace
          where n.nspname='app'
            and p.proname in ('list_staff','list_clients','revenue_summary','employee_workload')
          order by p.proname;
          SQL

      - name: Analytics sanity queries
        id: analytics_queries
        env:
          PGHOST: db.${{ secrets.SUPABASE_PROJECT_REF }}.supabase.co
          PGPORT: 6543
          PGUSER: postgres
          PGPASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
          PGDATABASE: postgres
        run: |
          set -e
          psql -v ON_ERROR_STOP=1 <<'SQL' > analytics_results.txt
          select 'revenue_summary 7d' as label,
                 app.revenue_summary((now()-interval '7 days')::timestamptz, now()::timestamptz);
          select 'employee_workload 7d' as label,
                 app.employee_workload((now()-interval '7 days')::timestamptz, now()::timestamptz, null);
          SQL
          cat analytics_results.txt

      - name: Install Node deps for smoke test
        run: |
          npm install @supabase/supabase-js uuid date-fns

      - name: Write smoke test script (if not present)
        run: |
          mkdir -p scripts
          if [ ! -f scripts/prod_smoke.ts ]; then
            cat > scripts/prod_smoke.ts <<'EOF_TS'
import { createClient } from '@supabase/supabase-js'
import { addMinutes } from 'date-fns'

const { SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY } = process.env

async function main() {
  if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    throw new Error('Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY')
  }
  const admin = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, { auth: { autoRefreshToken: false, persistSession: false } })
  const tag = Date.now()
  const staffName = `Prod Smoke Staff ${tag}`
  const clientName = `Prod Smoke Client ${tag}`
  const petName = `Prod Smoke Pet ${tag}`

  let businessId: string | null = null
  {
    const { data, error } = await admin.from('business').select('id').limit(1).maybeSingle()
    if (!error && data?.id) businessId = data.id
  }

  const staffInsert: any = { display_name: staffName }
  if (businessId) staffInsert.business_id = businessId
  const { data: staff, error: staffErr } = await admin.from('staff').insert(staffInsert).select().single()
  if (staffErr) throw new Error('Staff create failed: ' + staffErr.message)

  const { data: client, error: clientErr } = await admin.from('clients').insert({ display_name: clientName }).select().single()
  if (clientErr) throw new Error('Client create failed: ' + clientErr.message)

  const { data: pet, error: petErr } = await admin.from('pets').insert({ client_id: client.id, name: petName, species: 'dog' }).select().single()
  if (petErr) throw new Error('Pet create failed: ' + petErr.message)

  const start = new Date(); const end = addMinutes(start, 30)
  const { data: appointment, error: apptErr } = await admin.from('appointments')
    .insert({ staff_id: staff.id, client_id: client.id, start_at: start.toISOString(), end_at: end.toISOString(), status: 'scheduled' })
    .select().single()
  if (apptErr) throw new Error('Appointment create failed: ' + apptErr.message)

  const { data: apptUpd, error: apptUpdErr } = await admin.from('appointments')
    .update({ status: 'finished' }).eq('id', appointment.id).select().single()
  if (apptUpdErr) throw new Error('Appointment status update failed: ' + apptUpdErr.message)

  const { data: message, error: msgErr } = await admin.from('messages')
    .insert({ client_id: client.id, direction: 'outbound', body: `Smoke test message ${tag}` }).select().single()
  if (msgErr) throw new Error('Message send failed: ' + msgErr.message)

  let settings: any = null
  const { error: settingsCheckErr } = await admin.from('settings').select('id').eq('id', 1).limit(1)
  if (!settingsCheckErr) {
    const upd = await admin.from('settings')
      .update({ quiet_hours_start: '21:00', quiet_hours_end: '07:00' })
      .eq('id', 1).select().maybeSingle()
    settings = upd.data ?? null
  }

  console.log(JSON.stringify({ staff, client, pet, appointment_initial: appointment, appointment_updated: apptUpd, message, settings }, null, 2))
}
main().catch(e => { console.error('SMOKE_TEST_FAILURE:', e); process.exit(1) })
EOF_TS
          fi

      - name: Compile smoke script (ts-node via npx)
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          npx ts-node scripts/prod_smoke.ts > smoke-results.json

      - name: Collect artifacts
        run: |
          echo "## Rollout Summary" > summary.md
          echo "" >> summary.md
          echo "**Run ID:** $GITHUB_RUN_ID" >> summary.md
          echo "**Timestamp:** $(date -u)" >> summary.md
          echo "" >> summary.md
          echo "### Analytics Queries Output" >> summary.md
          echo '```' >> summary.md
          cat analytics_results.txt >> summary.md
          echo '```' >> summary.md
          echo "" >> summary.md
          echo "### Smoke Test JSON (truncated)" >> summary.md
          echo '```json' >> summary.md
          head -n 120 smoke-results.json >> summary.md
          echo '```' >> summary.md

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: prod-rollout-${{ env.ROLLOUT_TIMESTAMP }}
          path: |
            analytics_results.txt
            smoke-results.json
            summary.md

      - name: Optional Vercel redeploy
        if: ${{ secrets.VERCEL_TOKEN != '' && secrets.VERCEL_PROJECT_ID != '' }}
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_TEAM_ID: ${{ secrets.VERCEL_TEAM_ID }}
        run: |
          echo "Triggering Vercel redeploy (optional step)..."
          curl -s -X POST "https://api.vercel.com/v13/deployments" \
            -H "Authorization: Bearer $VERCEL_TOKEN" \
            -H "Content-Type: application/json" \
            --data "{\"name\":\"prod-rollout-${GITHUB_RUN_ID}\",\"projectId\":\"$VERCEL_PROJECT_ID\",\"target\":\"production\",\"teamId\":\"$VERCEL_TEAM_ID\"}" \
            | sed 's/\"deploymentId\"/\n\"deploymentId\"/'

      - name: Post PR comment summary
        if: ${{ always() }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.inputs.pr_number }}"
          STATUS="SUCCESS"
          if [ "${{ job.status }}" != "success" ]; then
            STATUS="FAILURE"
          fi
          body=$(cat <<'EOF'
### Production Rollout Summary

Status: PLACEHOLDER_STATUS

Artifacts:
- Rollout bundle (analytics + smoke JSON + summary.md) attached to workflow run.

Key Steps:
1. Migrations applied (supabase db push).
2. RPC anon EXECUTE revoked (idempotent pass).
3. Analytics sanity queries executed.
4. Smoke test inserted staff, client, pet, appointment, message; updated appointment & quiet hours (if table exists).

If FAILURE: inspect artifacts + logs for SMOKE_TEST_FAILURE or SQL errors.

_This comment was posted automatically._
EOF
)
          body="${body/PLACEHOLDER_STATUS/${STATUS}}"
          echo "$body" > pr_comment.md
          gh pr comment "$PR_NUMBER" --body-file pr_comment.md || echo "PR comment failed (ensure PR exists)."
