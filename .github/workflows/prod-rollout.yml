name: Prod Rollout

on:
  workflow_dispatch:
    inputs:
      env:
        description: "Target environment (must be 'production')"
        required: true
        default: "production"
      confirm_prod:
        description: "Type YES to confirm live production rollout"
        required: true
        default: "NO"
      pr_number:
        description: "PR number to comment on (default 328)"
        required: false
        default: "328"

env:
  ROLLOUT_TIMESTAMP: ${{ github.run_id }}-${{ github.run_number }}

jobs:
  prod-rollout:
    name: Run Production Rollout
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Validate inputs
        run: |
          if [ "${{ github.event.inputs.env }}" != "production" ]; then
            echo "ERROR: env must be 'production'." >&2
            exit 1
          fi
          if [ "${{ github.event.inputs.confirm_prod }}" != "YES" ]; then
            echo "ERROR: confirm_prod must be YES to proceed." >&2
            exit 1
          fi

      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install Supabase CLI
        run: |
          curl -fsSL https://deno.land/install.sh | sh -s v1.46.3
          export DENO_INSTALL="$HOME/.deno"
          export PATH="$DENO_INSTALL/bin:$PATH"
          curl -fsSL https://github.com/supabase/cli/releases/download/v1.189.6/supabase_1.189.6_linux_amd64.tar.gz \
            | tar -xz -C /usr/local/bin supabase
          supabase --version

      - name: Configure Supabase project ref
        run: |
          mkdir -p supabase
          echo "project_id = \"${{ secrets.SUPABASE_PROJECT_REF }}\"" > supabase/config.toml

      - name: Supabase DB Push (Migrations)
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          supabase db push --project-ref "${{ secrets.SUPABASE_PROJECT_REF }}"

      - name: Install psql client
        run: |
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client

      - name: Audit & Revoke anon EXECUTE on RPCs
        id: rpc_audit
        env:
          PGHOST: db.${{ secrets.SUPABASE_PROJECT_REF }}.supabase.co
          PGPORT: 6543
          PGUSER: postgres
          PGPASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
          PGDATABASE: postgres
        run: |
          set -e
          echo "== Current function ACLs =="
          psql -v ON_ERROR_STOP=1 <<'SQL'
          select
            n.nspname as schema,
            p.proname as function,
            p.prosecdef as security_definer,
            p.proacl
          from pg_proc p
          join pg_namespace n on n.oid = p.pronamespace
          where n.nspname='app'
            and p.proname in ('list_staff','list_clients','revenue_summary','employee_workload')
          order by p.proname;
          SQL

          echo "== Revoking anon (idempotent) =="
          psql -v ON_ERROR_STOP=1 <<'SQL'
          DO $$
          DECLARE r RECORD;
          BEGIN
            FOR r IN
              select p.proname, pg_get_function_identity_arguments(p.oid) as args
              from pg_proc p
              join pg_namespace n on n.oid = p.pronamespace
              where n.nspname='app'
                and p.proname in ('list_staff','list_clients','revenue_summary','employee_workload')
            LOOP
              EXECUTE format('REVOKE EXECUTE ON FUNCTION app.%I(%s) FROM anon;', r.proname, r.args);
            END LOOP;
          END$$;
          SQL

          echo "== Post-revoke function ACLs =="
          psql -v ON_ERROR_STOP=1 <<'SQL'
          select
            p.proname,
            unnest(coalesce(p.proacl, ARRAY[]::aclitem[])) acl
          from pg_proc p
          join pg_namespace n on n.oid = p.pronamespace
          where n.nspname='app'
            and p.proname in ('list_staff','list_clients','revenue_summary','employee_workload')
          order by p.proname;
          SQL

      - name: Analytics sanity queries
        id: analytics_queries
        env:
          PGHOST: db.${{ secrets.SUPABASE_PROJECT_REF }}.supabase.co
          PGPORT: 6543
          PGUSER: postgres
          PGPASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
          PGDATABASE: postgres
        run: |
          set -e
          psql -v ON_ERROR_STOP=1 <<'SQL' > analytics_results.txt
          select 'revenue_summary 7d' as label,
                 app.revenue_summary((now()-interval '7 days')::timestamptz, now()::timestamptz);
          select 'employee_workload 7d' as label,
                 app.employee_workload((now()-interval '7 days')::timestamptz, now()::timestamptz, null);
          SQL
          echo "Analytics queries complete."

      - name: Install Node deps for smoke test
        run: |
          npm install @supabase/supabase-js

      - name: Ensure smoke script present
        run: |
          if [ ! -f scripts/prod_smoke.ts ]; then
            echo "Smoke script missing. Creating minimal version."
            mkdir -p scripts
            cat > scripts/prod_smoke.ts <<'EOF'
import { createClient } from '@supabase/supabase-js'
function addMinutes(d: Date, m: number){return new Date(d.getTime()+m*60000)}
const { SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY } = process.env
async function main(){
 if(!SUPABASE_URL||!SUPABASE_SERVICE_ROLE_KEY) throw new Error('Missing env')
 const admin=createClient(SUPABASE_URL,SUPABASE_SERVICE_ROLE_KEY,{auth:{autoRefreshToken:false,persistSession:false}})
 const tag=Date.now()
 const staffName=`Prod Smoke Staff ${tag}`
 const clientName=`Prod Smoke Client ${tag}`
 const petName=`Prod Smoke Pet ${tag}`
 let businessId:null|string=null
 const b=await admin.from('business').select('id').limit(1).maybeSingle()
 if(!b.error && b.data?.id) businessId=b.data.id
 const staffIns:any={display_name:staffName}; if(businessId) staffIns.business_id=businessId
 const staff=(await admin.from('staff').insert(staffIns).select().single()).data
 const client=(await admin.from('clients').insert({display_name:clientName}).select().single()).data
 const pet=(await admin.from('pets').insert({client_id:client.id,name:petName,species:'dog'}).select().single()).data
 const start=new Date(); const end=addMinutes(start,30)
 const appointment=(await admin.from('appointments').insert({staff_id:staff.id,client_id:client.id,start_at:start.toISOString(),end_at:end.toISOString(),status:'scheduled'}).select().single()).data
 const appointment_updated=(await admin.from('appointments').update({status:'finished'}).eq('id',appointment.id).select().single()).data
 const message=(await admin.from('messages').insert({client_id:client.id,direction:'outbound',body:`Smoke test message ${tag}`}).select().single()).data
 let settings=null
 const sc=await admin.from('settings').select('id').eq('id',1).limit(1)
 if(!sc.error){ const upd=await admin.from('settings').update({quiet_hours_start:'21:00',quiet_hours_end:'07:00'}).eq('id',1).select().maybeSingle(); settings=upd.data??null }
 console.log(JSON.stringify({staff,client,pet,appointment_initial:appointment,appointment_updated,message,settings},null,2))
}
main().catch(e=>{console.error('SMOKE_TEST_FAILURE:',e);process.exit(1)})
EOF
          fi

      - name: Run smoke script
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          npx ts-node scripts/prod_smoke.ts > smoke-results.json

      - name: Collect artifacts
        run: |
          {
            echo "## Rollout Summary"
            echo
            echo "**Run ID:** $GITHUB_RUN_ID"
            echo "**Timestamp:** $(date -u)"
            echo
            echo "### Analytics Queries Output"
            echo '```'
            cat analytics_results.txt
            echo '```'
            echo
            echo "### Smoke Test JSON (truncated)"
            echo '```json'
            head -n 120 smoke-results.json
            echo '```'
          } > summary.md

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: prod-rollout-${{ env.ROLLOUT_TIMESTAMP }}
          path: |
            analytics_results.txt
            smoke-results.json
            summary.md

      - name: Post PR comment summary
        if: ${{ always() }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.inputs.pr_number }}"
          STATUS="${{ job.status }}"
          [ "$STATUS" = "success" ] && STATUS="SUCCESS" || STATUS="FAILURE"
          cat > pr_comment.md <<EOF
### Production Rollout Summary

Status: $STATUS

Artifacts:
- Rollout bundle (analytics + smoke JSON + summary.md) attached to workflow run.

Key Steps:
1. Migrations applied (supabase db push).
2. RPC anon EXECUTE revoked.
3. Analytics sanity queries executed.
4. Smoke test inserted staff, client, pet, appointment, message; updated appointment & (if exists) quiet hours.

If FAILURE: inspect artifacts + logs for SMOKE_TEST_FAILURE or SQL errors.

_This comment was posted automatically._
EOF
          gh pr comment "$PR_NUMBER" --body-file pr_comment.md || echo "PR comment failed (maybe PR closed)."
