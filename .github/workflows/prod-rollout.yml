name: Prod Rollout

on:
  workflow_dispatch:
    inputs:
      env:
        description: Must be production
        required: true
        default: production
      confirm_prod:
        description: Type YES to confirm
        required: true
        default: NO
      pr_number:
        description: Optional PR number to comment on
        required: false
        default: ""

env:
  ROLLOUT_TIMESTAMP: ${{ github.run_id }}-${{ github.run_number }}
  TARGET_FUNCS: "list_staff,list_clients,revenue_summary,employee_workload"
  SUPABASE_CLI_VERSION: v1.191.2

jobs:
  rollout:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:

      - name: Validate inputs
        run: |
          set -e
          if [ "${{ github.event.inputs.env }}" != "production" ]; then
            echo "env must be production"; exit 1
          fi
          if [ "${{ github.event.inputs.confirm_prod }}" != "YES" ]; then
            echo "confirm_prod must be YES"; exit 1
          fi
          echo "Inputs validated."

      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Supabase CLI (robust)
        run: |
          set -e
          V="${SUPABASE_CLI_VERSION:-v1.191.2}"
          echo "Installing Supabase CLI $V"
          TMPDIR="$(mktemp -d)"
          ARCH=$(uname -m)
          case "$ARCH" in
            x86_64) ARCH=amd64 ;;
            aarch64|arm64) ARCH=arm64 ;;
          esac
          OS=$(uname -s | tr '[:upper:]' '[:lower:]')
          TARBALL="supabase_${OS}_${ARCH}.tar.gz"
          URL="https://github.com/supabase/cli/releases/download/${V}/${TARBALL}"
          echo "Download URL: $URL"
          if curl -fsSL "$URL" -o "$TMPDIR/$TARBALL"; then
            tar -xzf "$TMPDIR/$TARBALL" -C "$TMPDIR"
            sudo mv "$TMPDIR/supabase" /usr/local/bin/supabase
          else
            echo "Binary download failed; trying official install script..."
            if ! curl -fsSL https://supabase.com/cli/install | sh -s -- -b /usr/local/bin; then
              echo "Install script failed; falling back to npm."
              npm install -g supabase || { echo "All install methods failed"; exit 1; }
            fi
          fi
          supabase --version || { echo "Supabase CLI not working after install"; exit 1; }

      - name: Prepare Supabase config (sanitize project ref)
        run: |
          set -e
          RAW="${{ secrets.SUPABASE_PROJECT_REF }}"
          if [ -z "$RAW" ]; then
            echo "SUPABASE_PROJECT_REF secret is empty"; exit 1
          fi
          CLEAN=$(printf "%s" "$RAW" | tr -d '\r\n\"\'"'"' ')
          if ! echo "$CLEAN" | grep -Eq '^[a-z0-9]{15,30}$'; then
            echo "Sanitized project ref '$CLEAN' looks invalid. Raw='$RAW'"; exit 1
          fi
          echo "Using project ref: $CLEAN"
          mkdir -p supabase
          printf 'project_id = "%s"\n' "$CLEAN" > supabase/config.toml
          echo "PROJECT_REF=$CLEAN" >> $GITHUB_ENV
          echo "supabase/config.toml:"
          cat supabase/config.toml

      - name: Apply migrations (supports link or direct db-url)
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
        run: |
          set -e
          supabase --version
          echo "Mode selection:"
          echo " - SUPABASE_ACCESS_TOKEN present?  $( [ -n "$SUPABASE_ACCESS_TOKEN" ] && echo yes || echo no )"
          echo " - SUPABASE_DB_PASSWORD present?   $( [ -n "$SUPABASE_DB_PASSWORD" ] && echo yes || echo no )"
          if [ -n "$SUPABASE_ACCESS_TOKEN" ]; then
            echo "Linking project via access token..."
            supabase link --project-ref "$PROJECT_REF"
            echo "Running supabase db push (linked mode)..."
            supabase db push
          elif [ -n "$SUPABASE_DB_PASSWORD" ]; then
            echo "No access token; using direct db-url fallback."
            DB_URL="postgresql://postgres:${SUPABASE_DB_PASSWORD}@db.${PROJECT_REF}.supabase.co:6543/postgres"
            # Percent-encode any special characters in password minimally (colon/@ already handled by structure if no weird chars).
            echo "Running supabase db push with --db-url ..."
            supabase db push --db-url "$DB_URL"
          else
            echo "Neither SUPABASE_ACCESS_TOKEN nor SUPABASE_DB_PASSWORD provided; cannot run migrations."
            exit 1
          fi
          echo "Migrations done."

      - name: Install psql client (skip if no DB password)
        run: |
          if [ -z "${{ secrets.SUPABASE_DB_PASSWORD }}" ]; then
            echo "SUPABASE_DB_PASSWORD not set; skipping psql install."
            exit 0
          fi
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client

      - name: Revoke anon EXECUTE (safe / idempotent; skipped if no DB password)
        env:
          PGHOST: db.${{ secrets.SUPABASE_PROJECT_REF }}.supabase.co
          PGPORT: 6543
          PGUSER: postgres
          PGPASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
          PGDATABASE: postgres
          FN_LIST: ${{ env.TARGET_FUNCS }}
        run: |
          if [ -z "${{ secrets.SUPABASE_DB_PASSWORD }}" ]; then
            echo "No DB password; skipping revoke."
            exit 0
          fi
          set -e
          cat > revoke_funcs.sql <<'EOF'
          drop table if exists tmp_target_funcs;
          create temporary table tmp_target_funcs(name text, arg_sig text);

          with desired as (
            select unnest(string_to_array(current_setting('FN_LIST', true), ',')) as fn
          ),
          existing as (
            select p.proname,
                   pg_get_function_identity_arguments(p.oid) as arg_sig
            from pg_proc p
            join pg_namespace n on n.oid = p.pronamespace
            where n.nspname='app'
              and p.proname in (select fn from desired)
          )
          insert into tmp_target_funcs
          select proname, arg_sig from existing;

          DO $$
          DECLARE r record;
          BEGIN
            FOR r IN SELECT * FROM tmp_target_funcs LOOP
              BEGIN
                EXECUTE format('REVOKE EXECUTE ON FUNCTION app.%I(%s) FROM anon;', r.name, r.arg_sig);
              EXCEPTION WHEN OTHERS THEN
                RAISE NOTICE 'Could not revoke app.% (%): %', r.name, r.arg_sig, SQLERRM;
              END;
            END LOOP;
          END$$;

          select
            proname,
            coalesce(array_to_string(array_agg(acl::text), E'\n'), '(no acl)') as acl_lines
          from (
            select p.proname, unnest(coalesce(p.proacl, ARRAY[]::aclitem[])) as acl
            from pg_proc p
            join pg_namespace n on n.oid = p.pronamespace
            where n.nspname='app'
              and p.proname in (select name from tmp_target_funcs)
          ) q
          group by 1
          order by 1;
          EOF
          psql -v ON_ERROR_STOP=1 -v FN_LIST="$FN_LIST" -f revoke_funcs.sql > revoke_output.txt
          echo "Revoke phase complete."

      - name: Analytics existence + sample calls (non-fatal; skipped if no DB password)
        env:
          PGHOST: db.${{ secrets.SUPABASE_PROJECT_REF }}.supabase.co
          PGPORT: 6543
          PGUSER: postgres
          PGPASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
          PGDATABASE: postgres
        run: |
          if [ -z "${{ secrets.SUPABASE_DB_PASSWORD }}" ]; then
            echo "No DB password; skipping analytics checks."
            exit 0
          fi
          set +e
          cat > analytics.sql <<'EOF'
          with fns(name) as (values ('revenue_summary'), ('employee_workload'))
          select f.name,
                 case when exists (
                   select 1 from pg_proc p
                   join pg_namespace n on n.oid=p.pronamespace
                   where n.nspname='app' and p.proname=f.name
                 ) then 'PRESENT' else 'MISSING' end as status
          from fns f
          order by 1;

          DO $$
          BEGIN
            BEGIN
              PERFORM app.revenue_summary((now()-interval '7 days')::timestamptz, now()::timestamptz);
              RAISE NOTICE 'revenue_summary call ok';
            EXCEPTION WHEN OTHERS THEN
              RAISE NOTICE 'revenue_summary call failed: %', SQLERRM;
            END;

            BEGIN
              PERFORM app.employee_workload((now()-interval '7 days')::timestamptz, now()::timestamptz, NULL);
              RAISE NOTICE 'employee_workload call ok';
            EXCEPTION WHEN OTHERS THEN
              RAISE NOTICE 'employee_workload call failed: %', SQLERRM;
            END;
          END$$;
          EOF
          psql -v ON_ERROR_STOP=0 -f analytics.sql > analytics_results.txt 2>&1
          echo "Analytics inspection done."

      - name: Setup Node (for smoke)
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install runtime deps
        run: |
          npm install @supabase/supabase-js tsx --no-audit --no-fund

      - name: Create adaptive smoke script
        run: |
          mkdir -p scripts
          cat > scripts/prod_smoke.ts <<'EOF'
          import { createClient } from '@supabase/supabase-js'
          function addMinutes(d:Date,m:number){return new Date(d.getTime()+m*60000)}
          const { SUPABASE_URL,SUPABASE_SERVICE_ROLE_KEY } = process.env
          async function main(){
            if(!SUPABASE_URL||!SUPABASE_SERVICE_ROLE_KEY) throw new Error('Missing env')
            const admin = createClient(SUPABASE_URL,SUPABASE_SERVICE_ROLE_KEY,{
              auth:{autoRefreshToken:false,persistSession:false}
            })
            const tag=Date.now()
            const out:any={ meta:{ tag, started:new Date().toISOString() } }

            let staff:any=null; let staffTable='public.employees'
            try{
              const r=await admin.from('employees').insert({ name:`Smoke Staff ${tag}` }).select().single()
              if(r.error) throw r.error; staff=r.data
            }catch(e:any){
              if(/does not exist/i.test(e.message||'')){
                staffTable='app.staff'
                const r=await admin.from('staff').insert({
                  first_name:'Smoke', last_name:'Staff'+tag,
                  email:`smoke_staff_${tag}@example.com`,
                  phone:'+10000000000', status:'active'
                }).select().single()
                if(r.error) throw r.error; staff=r.data
              } else throw e
            }
            out.staff=staff; out.staff_table=staffTable

            let client:any=null
            try{
              const r=await admin.from('clients').insert({ display_name:`Smoke Client ${tag}` }).select().single()
              if(r.error) throw r.error; client=r.data; out.client=client
            }catch(e:any){ out.client_error=e.message }

            if(client?.id){
              try{
                const r=await admin.from('pets').insert({ client_id:client.id, name:`Smoke Pet ${tag}`, species:'dog'}).select().single()
                if(r.error) throw r.error; out.pet=r.data
              }catch(e:any){ out.pet_error=e.message }
            }

            const start=new Date(); const end=addMinutes(start,30)
            async function variantA(){
              const r=await admin.from('appointments').insert({
                staff_id:staff?.id, client_id:client?.id,
                start_at:start.toISOString(), end_at=end.toISOString(),
                status:'scheduled'
              }).select().single()
              if(r.error) throw r.error; return r.data
            }
            async function variantB(){
              const r=await admin.from('appointments').insert({
                staff_id:staff?.id, client_id:client?.id,
                starts_at:start.toISOString(), ends_at=end.toISOString(),
                price_service:0, status:'booked'
              }).select().single()
              if(r.error) throw r.error; return r.data
            }
            try{
              let appt:any
              try{
                appt=await variantA(); out.appointment_mode='variant_A'
                const upd=await admin.from('appointments').update({ status:'finished'}).eq('id',appt.id).select().single()
                if(upd.error) throw upd.error
                out.appointment_initial=appt; out.appointment_updated=upd.data
              }catch(e:any){
                if(/column .* does not exist|invalid input value for enum|status/i.test(e.message)){
                  appt=await variantB(); out.appointment_mode='variant_B'
                  const upd=await admin.from('appointments').update({ status:'completed'}).eq('id',appt.id).select().single()
                  if(upd.error) throw upd.error
                  out.appointment_initial=appt; out.appointment_updated=upd.data
                } else throw e
              }
            }catch(e:any){ out.appointment_error=e.message }

            try{
              const r=await admin.from('messages').insert({
                client_id:client?.id, direction:'outbound', body:`Smoke test message ${tag}`
              }).select().single()
              if(r.error) throw r.error; out.message=r.data
            }catch(e:any){
              if(/does not exist/i.test(e.message||'')) out.message_skipped='messages table missing'
              else out.message_error=e.message
            }

            try{
              const sel=await admin.from('settings').select('id').eq('id',1).limit(1)
              if(!sel.error){
                const upd=await admin.from('settings').update({
                  quiet_hours_start:'21:00', quiet_hours_end:'07:00'
                }).eq('id',1).select().maybeSingle()
                out.settings=upd.data??null
              } else out.settings_skipped='settings table not accessible'
            }catch(e:any){
              if(/does not exist/i.test(e.message||'')) out.settings_skipped='settings table missing'
              else out.settings_error=e.message
            }

            out.meta.finished=new Date().toISOString()
            console.log(JSON.stringify(out,null,2))
          }
          main().catch(e=>{ console.error('SMOKE_TEST_FAILURE:',e.message); process.exit(1) })
          EOF

      - name: Run smoke test
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          if [ -z "${{ secrets.SUPABASE_URL }}" ] || [ -z "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" ]; then
            echo "Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY; skipping smoke."
            echo '{}' > smoke-results.json
            exit 0
          fi
          npx tsx scripts/prod_smoke.ts > smoke-results.json || true
          head -n 40 smoke-results.json || true

      - name: Build summary
        run: |
          {
            echo "## Production Rollout Summary"
            echo
            echo "Run ID: $GITHUB_RUN_ID"
            echo "Status: ${{ job.status }}"
            echo "UTC: $(date -u)"
            echo
            echo "### Migrations"
            echo "Applied via supabase db push (link or db-url mode)."
            echo
            if [ -f revoke_output.txt ]; then
              echo "### Function Privilege Snapshot (first 60 lines)"
              echo '```'
              head -n 60 revoke_output.txt
              echo '```'
            else
              echo "### Function Privilege Snapshot"
              echo "Skipped (no DB password)."
            fi
            echo
            if [ -f analytics_results.txt ]; then
              echo "### Analytics Presence & Calls (first 100 lines)"
              echo '```'
              head -n 100 analytics_results.txt
              echo '```'
            else
              echo "### Analytics Presence & Calls"
              echo "Skipped (no DB password)."
            fi
            echo
            if [ -f smoke-results.json ]; then
              echo "### Smoke JSON (truncated)"
              echo '```json'
              head -n 120 smoke-results.json
              echo '```'
            fi
          } > summary.md

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rollout-${{ env.ROLLOUT_TIMESTAMP }}
          path: |
            summary.md
            revoke_output.txt
            analytics_results.txt
            smoke-results.json

      - name: PR comment (if pr_number provided)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -z "${{ github.event.inputs.pr_number }}" ]; then
            echo "No pr_number provided; skipping comment."
            exit 0
          fi
          {
            echo "### Prod Rollout"
            echo
            echo "**Status:** ${{ job.status }}"
            echo "[Run ID $GITHUB_RUN_ID](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"
            echo
            echo "Artifacts include summary.md (migrations, revoke snapshot, analytics, smoke)."
            echo
            echo "_Automated comment._"
          } > pr_comment.md
          gh pr comment "${{ github.event.inputs.pr_number }}" --body-file pr_comment.md || echo "PR comment failed."

      - name: Tag rollout (success only)
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="rollout-${{ github.run_id }}"
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git tag -a "$TAG" -m "Prod rollout $TAG"
          git push origin "$TAG" || echo "Tag push failed (non-fatal)."
