-- Staff module schema and supporting routines

create table if not exists public.employees (
  id bigint generated by default as identity primary key,
  name text,
  email text,
  phone text,
  active boolean default true,
  role text,
  status text,
  address_street text,
  address_city text,
  address_state text,
  address_zip text,
  avatar_url text,
  emergency_contact_name text,
  emergency_contact_phone text,
  pay_type text,
  commission_rate numeric,
  hourly_rate numeric,
  salary_rate numeric,
  app_permissions jsonb default '{}'::jsonb,
  preferred_breeds text[] default '{}',
  not_accepted_breeds text[] default '{}',
  specialties text[] default '{}',
  manager_notes text,
  created_at timestamptz not null default timezone('utc'::text, now())
);

create table if not exists public.staff_goals (
  staff_id bigint primary key references public.employees(id) on delete cascade,
  weekly_revenue_target numeric,
  desired_dogs_per_day int,
  updated_at timestamptz not null default timezone('utc'::text, now())
);

create table if not exists public.appointment_discounts (
  id bigserial primary key,
  appointment_id bigint not null references public.appointments(id) on delete cascade,
  amount numeric not null check (amount >= 0),
  reason text not null,
  created_by bigint references public.employees(id),
  created_at timestamptz not null default timezone('utc'::text, now())
);

create table if not exists public.staff_shifts (
  id bigserial primary key,
  employee_id bigint not null references public.employees(id) on delete cascade,
  starts_at timestamptz not null,
  ends_at timestamptz not null,
  note text,
  created_at timestamptz not null default timezone('utc'::text, now())
);

create table if not exists public.staff_time_off (
  id bigserial primary key,
  employee_id bigint not null references public.employees(id) on delete cascade,
  starts_at timestamptz not null,
  ends_at timestamptz not null,
  reason text not null,
  status text not null default 'pending',
  created_at timestamptz not null default timezone('utc'::text, now())
);

create or replace view public.payroll_lines_view as
select
  a.id as appointment_id,
  a.employee_id as staff_id,
  a.start_time,
  a.end_time,
  a.service,
  coalesce(a.price, 0)::numeric as base_price,
  coalesce(e.commission_rate, 0)::numeric as commission_rate,
  coalesce(a.price, 0)::numeric * coalesce(e.commission_rate, 0)::numeric as commission_amount,
  -coalesce(d.total_discount, 0)::numeric as adjustment_amount,
  d.reasons as adjustment_reason,
  coalesce(a.price, 0)::numeric + coalesce(a.price, 0)::numeric * coalesce(e.commission_rate, 0)::numeric - coalesce(d.total_discount, 0)::numeric as final_earnings,
  case
    when a.start_time is null then null
    else ((floor((extract(doy from a.start_time) - 1) / 7)::int % 2) + 1)
  end as week_index
from public.appointments a
join public.employees e on e.id = a.employee_id
left join lateral (
  select
    coalesce(sum(amount), 0) as total_discount,
    string_agg(reason, '; ' order by created_at) as reasons
  from public.appointment_discounts ad
  where ad.appointment_id = a.id
) d on true;

create or replace function public.staff_today_metrics(staff_id bigint)
returns table(dogs integer, hours numeric)
language sql
security definer
set search_path = public
as $$
  select
    count(*)::int as dogs,
    coalesce(sum(greatest(extract(epoch from coalesce(a.end_time, a.start_time) - a.start_time) / 3600, 0)), 0)::numeric as hours
  from public.appointments a
  where a.employee_id = staff_id
    and a.start_time >= date_trunc('day', now())
    and a.start_time < date_trunc('day', now()) + interval '1 day';
$$;

create or replace function public.staff_week_metrics(staff_id bigint)
returns table(dogs integer, revenue numeric, commission numeric)
language sql
security definer
set search_path = public
as $$
  select
    count(*)::int as dogs,
    coalesce(sum(coalesce(a.price, 0)), 0)::numeric as revenue,
    coalesce(sum(coalesce(a.price, 0) * coalesce(e.commission_rate, 0)), 0)::numeric as commission
  from public.appointments a
  join public.employees e on e.id = a.employee_id
  where a.employee_id = staff_id
    and a.start_time >= date_trunc('week', now())
    and a.start_time < date_trunc('week', now()) + interval '7 days';
$$;

create or replace function public.staff_lifetime_metrics(staff_id bigint)
returns table(dogs integer, revenue numeric)
language sql
security definer
set search_path = public
as $$
  select
    count(*)::int as dogs,
    coalesce(sum(coalesce(a.price, 0)), 0)::numeric as revenue
  from public.appointments a
  where a.employee_id = staff_id;
$$;

-- grant execute permissions to authenticated users
grant execute on function public.staff_today_metrics(bigint) to authenticated;
grant execute on function public.staff_week_metrics(bigint) to authenticated;
grant execute on function public.staff_lifetime_metrics(bigint) to authenticated;

-- Row level security policies
alter table public.employees enable row level security;
alter table public.staff_goals enable row level security;
alter table public.appointment_discounts enable row level security;
alter table public.staff_shifts enable row level security;
alter table public.staff_time_off enable row level security;

create policy if not exists "Employees base view" on public.employees
  for select
  using (
    auth.role() = 'authenticated'
    and (manager_notes is null or coalesce((auth.jwt() ->> 'is_manager')::boolean, false))
  );

create policy if not exists "Employees manager view" on public.employees
  for select
  using (coalesce((auth.jwt() ->> 'is_manager')::boolean, false));

create policy if not exists "Employees manager update" on public.employees
  for update
  using (coalesce((auth.jwt() ->> 'is_manager')::boolean, false))
  with check (coalesce((auth.jwt() ->> 'is_manager')::boolean, false));

create policy if not exists "Appointment discounts read" on public.appointment_discounts
  for select
  using (auth.role() = 'authenticated');

create policy if not exists "Appointment discounts manage" on public.appointment_discounts
  for all
  using (coalesce((auth.jwt() ->> 'is_manager')::boolean, false))
  with check (coalesce((auth.jwt() ->> 'is_manager')::boolean, false));

create policy if not exists "Staff goals read" on public.staff_goals
  for select
  using (
    auth.role() = 'authenticated'
    and (
      coalesce((auth.jwt() ->> 'is_manager')::boolean, false)
      or staff_id::text = coalesce(auth.jwt() ->> 'employee_id', '0')
    )
  );

create policy if not exists "Staff goals manage" on public.staff_goals
  for all
  using (coalesce((auth.jwt() ->> 'is_manager')::boolean, false))
  with check (coalesce((auth.jwt() ->> 'is_manager')::boolean, false));

create policy if not exists "Staff shifts read" on public.staff_shifts
  for select
  using (
    auth.role() = 'authenticated'
    and (
      employee_id::text = coalesce(auth.jwt() ->> 'employee_id', '0')
      or coalesce((auth.jwt() ->> 'is_manager')::boolean, false)
    )
  );

create policy if not exists "Staff shifts self insert" on public.staff_shifts
  for insert
  with check (
    auth.role() = 'authenticated'
    and employee_id::text = coalesce(auth.jwt() ->> 'employee_id', '0')
  );

create policy if not exists "Staff shifts manage" on public.staff_shifts
  for all
  using (coalesce((auth.jwt() ->> 'is_manager')::boolean, false))
  with check (coalesce((auth.jwt() ->> 'is_manager')::boolean, false));

create policy if not exists "Time off read" on public.staff_time_off
  for select
  using (
    auth.role() = 'authenticated'
    and (
      employee_id::text = coalesce(auth.jwt() ->> 'employee_id', '0')
      or coalesce((auth.jwt() ->> 'is_manager')::boolean, false)
    )
  );

create policy if not exists "Time off request" on public.staff_time_off
  for insert
  with check (
    auth.role() = 'authenticated'
    and employee_id::text = coalesce(auth.jwt() ->> 'employee_id', '0')
  );

create policy if not exists "Time off manage" on public.staff_time_off
  for update
  using (coalesce((auth.jwt() ->> 'is_manager')::boolean, false))
  with check (coalesce((auth.jwt() ->> 'is_manager')::boolean, false));
